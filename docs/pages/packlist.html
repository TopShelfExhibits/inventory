<div id="tabSystem">
</div>

<script type="module">
    import { TabManager, GoogleSheetsService, GoogleSheetsAuth, TableManager, ModalManager, SPREADSHEET_IDS } from './js/index.js';

    function buildPackListTable(content, tabName = null) {
        const mainTableData = content.crates.map((crate, crateIdx) => {
            const itemData = document.createElement('div');
            itemData.classList.add('table-wrapper');
            let itemTable = null;
            let saveBtn = null;
            if (crate.items.length > 0) {
                itemTable = TableManager.buildTable(
                    crate.items,
                    content.headers.items,
                    ['Pack', 'Check'],
                    ['Description','Packing/shop notes'],
                    'pack-list-items',
                    ['.tab-button'],
                    newRowFunction
                );
                
                // Add save button for crate items if tabName is provided
                /*if (tabName) {
                    saveBtn = document.createElement('button');
                    saveBtn.textContent = 'Save Crate Changes';
                    saveBtn.className = 'save-button';
                    saveBtn.style.margin = '8px 0';
                    saveBtn.disabled = true;
                    itemData.appendChild(saveBtn);

                    TableManager.setupPackListSaveButton(itemTable, saveBtn, tabName, content.headers.items, crateIdx);
                }*/

                itemData.appendChild(itemTable);
            }
            return [...crate.info, itemData];
        });

        const headers = [...content.headers.main, 'Items'];
        const mainTable = TableManager.buildTable(
            mainTableData,
            headers,
            [],
            [],
            'pack-list',
            ['.tab-button'],
            newRowFunction
        );

        // Add whole-table save button if tabName is provided
        if (tabName) {
            const saveAllBtn = document.createElement('button');
            saveAllBtn.textContent = 'Save Pack List Changes';
            saveAllBtn.className = 'save-button';
            saveAllBtn.style.margin = '12px 0';
            saveAllBtn.disabled = true;

            // Enable button if any cell is dirty or any row is moved
            const checkSaveAllState = () => {
                // Check for any dirty cell in main table or any sub-table
                const dirty = mainTable.querySelector('.table-edit-textarea.dirty');
                // Check for any row moved (originalIndex != current index) in main table or any sub-table
                let moved = false;
                // Check main table
                const checkMoved = (tbody) => {
                    if (!tbody) return false;
                    return Array.from(tbody.rows).some((row, idx) =>
                        row.dataset.originalIndex !== undefined && parseInt(row.dataset.originalIndex) !== idx
                    );
                };
                const mainTbody = mainTable.querySelector('tbody');
                if (checkMoved(mainTbody)) moved = true;
                // Check all sub-tables
                mainTable.querySelectorAll('table').forEach(subTable => {
                    if (subTable === mainTable) return;
                    const subTbody = subTable.querySelector('tbody');
                    if (checkMoved(subTbody)) moved = true;
                });
                saveAllBtn.disabled = !(dirty || moved);
            };

            // Observe dirty state and row moves
            const observer = new MutationObserver(checkSaveAllState);
            observer.observe(mainTable, {
                subtree: true,
                attributes: true,
                attributeFilter: ['data-dirty', 'data-original-index', 'class']
            });
            // Also observe for row additions/removals (childList)
            observer.observe(mainTable.querySelector('tbody'), {
                childList: true,
                subtree: true // only direct children (rows)
            });

            // Also check on input events (for contenteditable changes)
            mainTable.addEventListener('input', checkSaveAllState);

            // Also check after drag/drop (row move)
            mainTable.addEventListener('mouseup', () => setTimeout(checkSaveAllState, 10));

            saveAllBtn.onclick = async () => {
                saveAllBtn.disabled = true;
                try {
                    await savePackListTable(
                        mainTable,
                        SPREADSHEET_IDS.PACK_LISTS,
                        tabName
                    );
                    ModalManager.alert('Entire pack list saved successfully');
                } catch (err) {
                    console.error('Error saving entire pack list:', err && err.stack ? err.stack : err);
                    ModalManager.alert('Error saving entire pack list: ' + (err && err.message ? err.message : err));
                } finally {
                    checkSaveAllState();
                }
            };
            // Wrap table and button in a container
            const wrapper = document.createElement('div');
            wrapper.appendChild(saveAllBtn);
            wrapper.appendChild(mainTable);
            return wrapper;
        }
        return mainTable;
    }

    async function checkPackListQuantities(tabName, container) {
        try {
            const quantityData = await GoogleSheetsService.checkItemQuantities(tabName);
            // Dynamically get headers from the first entry in the map
            const firstEntry = Object.values(quantityData)[0] || {};
            const headers = ['Item', 'Inventory', 'Requested', 'Remaining', 'Overlapping Shows', 'Status'];
            const rows = Object.entries(quantityData).map(([itemId, info]) => {
                const status = info.remaining > 0 ? 'OK' : 'Warning';
                const statusCell = document.createElement('span');
                statusCell.textContent = status;
                statusCell.style.color = status === 'OK' ? 'green' : 'red';
                
                return [
                    itemId,
                    info.inventory,
                    info.requested,
                    info.remaining,
                    buildTabsListElement(info.overlapping),
                    statusCell
                ];
            });

            const table = TableManager.buildTable(rows, headers);
            table.classList.add('quantity-check-table');
            
            // Create a div to hold the table with a logical heading
            const inventoryReportContainer = document.createElement('div');
            const heading = document.createElement('h2');
            heading.textContent = `Inventory report:`;
            inventoryReportContainer.classList.add('inventory-report-container');
            inventoryReportContainer.appendChild(heading);
            inventoryReportContainer.appendChild(table);
            container.appendChild(inventoryReportContainer);

            // For each inventory item with an error, find the pack list table and scan for
            // the corresponding item to highlight it
            // Find error items from rows (statusCell.textContent !== 'OK')
            console.log('Highlighting error items in pack list table...');
            rows.forEach(row => {
                const itemId = row[0];
                const remaining = row[3];
                const statusCell = row[row.length - 1];
                if (remaining < 0) {
                    // Insufficient inventory: red
                    const packListItems = container.querySelectorAll('.drag-id-pack-list-items td');
                    packListItems.forEach(packListItem => {
                        const itemRegex = /(?:\(([0-9]+)\))?\s*([A-Z]+-[0-9]+[a-zA-Z]?)/;
                        const match = packListItem.textContent.match(itemRegex);
                        if (match && match[2] === itemId) {
                            TableManager.tableCellCard(packListItem, `<strong>Warning: </strong>insufficient inventory (${remaining})`, 'red', '.inventory-report-container');
                        }
                    });
                } else if (remaining === 0) {
                    // No inventory margin: yellow
                    const packListItems = container.querySelectorAll('.drag-id-pack-list-items td');
                    packListItems.forEach(packListItem => {
                        const itemRegex = /(?:\(([0-9]+)\))?\s*([A-Z]+-[0-9]+[a-zA-Z]?)/;
                        const match = packListItem.textContent.match(itemRegex);
                        if (match && match[2] === itemId) {
                            TableManager.tableCellCard(packListItem, '<strong>Warning: </strong>no inventory margin', 'yellow', '.inventory-report-container');
                        }
                    });
                }
            });

        } catch (err) {
            console.error('Error building quantity check table:', err && err.stack ? err.stack : err);
            ModalManager.alert('Failed to check item quantities.');
        }
    }

    // Extracted function to build the tabs-list DOM element from a list of sheetTabs
    function buildTabsListElement(sheetTabs) {
        if (!sheetTabs || sheetTabs.length === 0) {
            const noTabsMessage = document.createElement('p');
            noTabsMessage.textContent = '-';
            return noTabsMessage;
        }
        
        const tabsList = document.createElement('div');
        tabsList.className = 'tabs-list';
        for (const tabName of sheetTabs) {
            if (tabName === 'TEMPLATE') continue;
            const tabButton = document.createElement('button');
            tabButton.classList.add('tab-button');
            tabButton.textContent = tabName;
            tabsList.appendChild(tabButton);
            tabButton.addEventListener('click', async () => {
                const loadingModal = ModalManager.showLoadingIndicator('Fetching and analyzing pack list...');
                try {
                    const content = await GoogleSheetsService.getPackListContent(tabName);
                    const tabContainer = document.createElement('div');
                    // Pass tabName to buildPackListTable so save buttons are added
                    const packListTable = buildPackListTable(content, tabName);
                    tabContainer.appendChild(packListTable);

                    // Asynchronously check item quantities
                    checkPackListQuantities(tabName, tabContainer);

                    TabManager.addNewTab('tabSystem', tabName, tabContainer, true, true);
                    loadingModal.hide();
                } catch (error) {
                    loadingModal.hide();
                    console.error('Error loading sheet content:', error);
                    ModalManager.alert('Failed to load spreadsheet content');
                }
                // Remove modal if present
                const modal = document.querySelector('.modal');
                if (modal) modal.remove();
            });
        }
        return tabsList;
    }

    // Standalone function for TabManager tab handler
    async function addNewPackListTab() {
        await GoogleSheetsAuth.checkAuth();

        const modal = ModalManager.createModal(`
            <p class="loading-message">Loading...</p>
        `);

        try {
            const sheetTabs = await GoogleSheetsService.getSheetTabs(SPREADSHEET_IDS.PACK_LISTS);
            const tabsListElement = buildTabsListElement(sheetTabs);
            const modalBody = modal.querySelector('.modal-body');
            modalBody.innerHTML = '';
            modalBody.appendChild(tabsListElement);
        } catch (error) {
            console.error('Error loading sheet tabs:', error);
            modal.querySelector('.modal-body').innerHTML = '<p class="error">Failed to load spreadsheet tabs</p>';
        }
    }

    /**
     * Save the entire pack list table (all crates and their items) to Google Sheets.
     * Only writes data rows (no header row).
     * @param {HTMLTableElement} mainTable - The main pack list table element.
     * @param {string} sheetId - The Google Sheets ID.
     * @param {string} tabName - The sheet/tab name.
     * @param {function} setSheetData - Function to call for saving (should match GoogleSheetsService.setSheetData).
     * @returns {Promise<void>}
     */
    async function savePackListTable(mainTable, sheetId, tabName) {
        const loadingModal = ModalManager.showLoadingIndicator('Saving pack list...');
        try {
            // 1. Gather all crate rows (main table body)
            const tbody = mainTable.querySelector('tbody');
            const crateRows = Array.from(tbody.querySelectorAll('tr'));
            const result = [];

            for (const crateRow of crateRows) {
                const crateCells = Array.from(crateRow.querySelectorAll('td'));
                // Only process rows with at least 7 cells (drag + 6 crate info + items)
                if (crateCells.length < 7) continue;

                // 2. Append crate data row (cells 1-6, skip drag handle)
                const crateData = crateCells.slice(1, 7).map(td => {
                    // If cell contains a contenteditable div, use its textContent
                    const editable = td.querySelector('.table-edit-textarea');
                    return editable ? editable.textContent.trim() : td.textContent.trim();
                });
                result.push(crateData);

                // 3. For each item in the crate's item table, append a row with 8 empty, then 2 item values
                const itemsCell = crateCells[6];
                const itemsTable = itemsCell.querySelector('table');
                if (itemsTable) {
                    const itemsTbody = itemsTable.querySelector('tbody');
                    if (itemsTbody) {
                        const itemRows = Array.from(itemsTbody.querySelectorAll('tr'));
                        for (const itemTr of itemRows) {
                            const itemTds = Array.from(itemTr.querySelectorAll('td')).slice(1); // skip drag handle
                            // Only process if there are at least 2 item columns
                            if (itemTds.length >= 2) {
                                const itemData = itemTds.map(td => {
                                    const editable = td.querySelector('.table-edit-textarea');
                                    return editable ? editable.textContent.trim() : td.textContent.trim();
                                });
                                // Only save if at least one item cell is non-empty
                                if (itemData.some(cell => cell.length > 0)) {
                                    result.push([
                                        '', '', '', '', '', '', '', '', // 8 empty columns
                                        ...itemData.slice(0, 2)
                                    ]);
                                }
                            }
                        }
                    }
                }
            }

            // Remove all data after row 3, then insert the new table at once
            if (typeof gapi !== 'undefined' && gapi.client?.sheets?.spreadsheets?.values?.batchClear) {
                await GoogleSheetsService.withExponentialBackoff(() =>
                    gapi.client.sheets.spreadsheets.values.batchClear({
                        spreadsheetId: sheetId,
                        resource: {
                            ranges: [`${tabName}!A4:J1000`]
                        }
                    })
                );
            }

            // Insert the new data starting at row 4, column A
            await GoogleSheetsService.setSheetData(sheetId, tabName, {
                type: 'full-table',
                values: Array.isArray(result) ? result : [],
                startRow: 3 // 1-based for Sheets API, row 4
            });

            // Delete any extra rows after the last data row
            // Get the current number of rows in the sheet
            if (typeof gapi !== 'undefined' && gapi.client?.sheets?.spreadsheets?.get) {
                const sheetInfo = await GoogleSheetsService.withExponentialBackoff(() =>
                    gapi.client.sheets.spreadsheets.get({
                        spreadsheetId: sheetId,
                        ranges: [tabName],
                        includeGridData: false
                    })
                );
                const sheet = sheetInfo.result.sheets.find(s => s.properties.title === tabName);
                if (sheet) {
                    const sheetRowCount = sheet.properties.gridProperties.rowCount;
                    const lastDataRow = 3 + result.length; // header is rows 1-3, data starts at row 4
                    if (sheetRowCount > lastDataRow) {
                        // Delete rows after the last data row (inclusive: lastDataRow+1 to sheetRowCount)
                        await GoogleSheetsService.withExponentialBackoff(() =>
                            gapi.client.sheets.spreadsheets.batchUpdate({
                                spreadsheetId: sheetId,
                                resource: {
                                    requests: [
                                        {
                                            deleteDimension: {
                                                range: {
                                                    sheetId: sheet.properties.sheetId,
                                                    dimension: 'ROWS',
                                                    startIndex: lastDataRow, // 0-based, so row N+1
                                                    endIndex: sheetRowCount
                                                }
                                            }
                                        }
                                    ]
                                }
                            })
                        );
                    }
                }
            }

            TableManager.clearDirtyState(mainTable);
        } finally {
            loadingModal.hide();
        }
    }

    function newRowFunction(event) {
            const btn = event.target.closest('.new-row-btn');
            if (!btn) return;
            const table = btn.closest('table');
            if (!table) return;
            const dragIdClass = Array.from(table.classList).find(cls => cls.startsWith('drag-id-'));
            const tbody = table.querySelector('tbody');
            if (!tbody) return;

            if (dragIdClass === 'drag-id-pack-list-items') {
                // Add a new draggable row with 2 editable cells
                const rowIndex = tbody.rows.length;
                const tr = document.createElement('tr');
                tr.classList.add('draggable');
                // Drag handle
                const dragTd = document.createElement('td');
                dragTd.className = 'row-drag-handle';
                tr.appendChild(dragTd);
                // 2 editable cells
                for (let i = 0; i < 2; i++) {
                    const td = document.createElement('td');
                    const editableDiv = document.createElement('div');
                    editableDiv.setAttribute('role', 'textbox');
                    editableDiv.setAttribute('contenteditable', 'true');
                    editableDiv.dataset.originalValue = '';
                    editableDiv.dataset.rowIndex = rowIndex;
                    editableDiv.dataset.colIndex = i + 2; // skip drag handle and possible hidden columns
                    editableDiv.dataset.dirty = 'false';
                    editableDiv.classList.add('table-edit-textarea');
                    editableDiv.addEventListener('input', (e) => {
                        const target = e.target;
                        const isDirty = (target.textContent !== target.dataset.originalValue);
                        target.dataset.dirty = isDirty.toString();
                        if (isDirty) {
                            target.classList.add('dirty');
                        } else {
                            target.classList.remove('dirty');
                        }
                    });
                    td.appendChild(editableDiv);
                    tr.appendChild(td);
                }
                tbody.appendChild(tr);
            } else if (dragIdClass === 'drag-id-pack-list') {
                // Add a new draggable row with 7 columns: first 6 editable, last is a new pack-list-items table
                const rowIndex = tbody.rows.length;
                const tr = document.createElement('tr');
                tr.classList.add('draggable');
                // Drag handle
                const dragTd = document.createElement('td');
                dragTd.className = 'row-drag-handle';
                tr.appendChild(dragTd);
                // 6 editable cells
                for (let i = 0; i < 6; i++) {
                    const td = document.createElement('td');
                    const editableDiv = document.createElement('div');
                    editableDiv.setAttribute('role', 'textbox');
                    editableDiv.setAttribute('contenteditable', 'true');
                    editableDiv.dataset.originalValue = '';
                    editableDiv.dataset.rowIndex = rowIndex;
                    editableDiv.dataset.colIndex = i + 1; // skip drag handle
                    editableDiv.dataset.dirty = 'false';
                    editableDiv.classList.add('table-edit-textarea');
                    editableDiv.addEventListener('input', (e) => {
                        const target = e.target;
                        const isDirty = (target.textContent !== target.dataset.originalValue);
                        target.dataset.dirty = isDirty.toString();
                        if (isDirty) {
                            target.classList.add('dirty');
                        } else {
                            target.classList.remove('dirty');
                        }
                    });
                    td.appendChild(editableDiv);
                    tr.appendChild(td);
                }
                // 7th cell: new pack-list-items table
                const itemsTd = document.createElement('td');
                itemsTd.className = 'table-wrapper';
                // Create an empty pack-list-items table with newRowFunction
                const itemsTable = TableManager.buildTable(
                    [],
                    content.headers.items,
                    ['Pack', 'Check'],
                    ['Description', 'Packing/shop notes'],
                    'pack-list-items',
                    ['.tab-button'],
                    newRowFunction
                );
                itemsTd.appendChild(itemsTable);
                tr.appendChild(itemsTd);
                tbody.appendChild(tr);
            }
        }
        

    // Initialize the TabManager with tab handler
    TabManager.buildTabSystem('tabSystem', addNewPackListTab);


</script>