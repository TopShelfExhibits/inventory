<div id="tabSystem">
</div>

<script type="module">
    import { TabManager, GoogleSheetsService, GoogleSheetsAuth, TableManager, ModalManager, SPREADSHEET_IDS } from './js/index.js';

    function buildPackListTable(content, tabName = null) {
        const mainTableData = content.crates.map((crate, crateIdx) => {
            const itemData = document.createElement('div');
            itemData.classList.add('table-wrapper');
            let itemTable = null;
            let saveBtn = null;
            if (crate.items.length > 0) {
                itemTable = TableManager.buildTable(
                    crate.items,
                    content.headers.items,
                    ['Pack', 'Check'],
                    ['Description','Packing/shop notes'],
                    'pack-list-items',
                    ['.tab-button']
                );
                
                // Add save button for crate items if tabName is provided
                if (tabName) {
                    saveBtn = document.createElement('button');
                    saveBtn.textContent = 'Save Changes';
                    saveBtn.className = 'save-button';
                    saveBtn.style.margin = '8px 0';
                    saveBtn.disabled = true;
                    itemData.appendChild(saveBtn);

                    TableManager.setupPackListSaveButton(itemTable, saveBtn, tabName, content.headers.items, crateIdx);
                }

                itemData.appendChild(itemTable);
            }
            return [...crate.info, itemData];
        });

        const headers = [...content.headers.main, 'Items'];
        const mainTable = TableManager.buildTable(mainTableData, headers, [], [], 'pack-list', ['.tab-button']);

        // Add whole-table save button if tabName is provided
        if (tabName) {
            const saveAllBtn = document.createElement('button');
            saveAllBtn.textContent = 'Save Entire Pack List';
            saveAllBtn.className = 'save-all-button';
            saveAllBtn.style.margin = '12px 0';
            saveAllBtn.disabled = true;

            // Enable button if any cell is dirty or any row is moved
            const checkSaveAllState = () => {
                // Check for any dirty cell
                const dirty = mainTable.querySelector('.table-edit-textarea.dirty');
                // Check for any row moved (originalIndex != current index)
                let moved = false;
                const tbody = mainTable.querySelector('tbody');
                if (tbody) {
                    Array.from(tbody.rows).forEach((row, idx) => {
                        if (row.dataset.originalIndex !== undefined && parseInt(row.dataset.originalIndex) !== idx) {
                            moved = true;
                        }
                    });
                }
                saveAllBtn.disabled = !(dirty || moved);
            };

            // Observe dirty state and row moves
            const observer = new MutationObserver(checkSaveAllState);
            observer.observe(mainTable, {
                subtree: true,
                attributes: true,
                attributeFilter: ['data-dirty', 'data-original-index', 'class']
            });

            // Also check on input events (for contenteditable changes)
            mainTable.addEventListener('input', checkSaveAllState);

            // Also check after drag/drop (row move)
            mainTable.addEventListener('mouseup', () => setTimeout(checkSaveAllState, 10));

            saveAllBtn.onclick = async () => {
                saveAllBtn.disabled = true;
                try {
                    await savePackListTable(
                        mainTable,
                        SPREADSHEET_IDS.PACK_LISTS,
                        tabName,
                        GoogleSheetsService.setSheetData
                    );
                    ModalManager.alert('Entire pack list saved successfully');
                } catch (err) {
                    console.error('Error saving entire pack list:', err && err.stack ? err.stack : err);
                    ModalManager.alert('Error saving entire pack list: ' + (err && err.message ? err.message : err));
                } finally {
                    checkSaveAllState();
                }
            };
            // Wrap table and button in a container
            const wrapper = document.createElement('div');
            wrapper.appendChild(saveAllBtn);
            wrapper.appendChild(mainTable);
            return wrapper;
        }
        return mainTable;
    }

    async function checkPackListQuantities(tabName, container) {
        try {
            const quantityData = await GoogleSheetsService.checkItemQuantities(tabName);
            // Dynamically get headers from the first entry in the map
            const firstEntry = Object.values(quantityData)[0] || {};
            const headers = ['Item', 'Inventory', 'Requested', 'Remaining', 'Overlapping Shows', 'Status'];
            const rows = Object.entries(quantityData).map(([itemId, info]) => {
                const status = info.remaining > 0 ? 'OK' : 'Warning';
                const statusCell = document.createElement('span');
                statusCell.textContent = status;
                statusCell.style.color = status === 'OK' ? 'green' : 'red';
                
                return [
                    itemId,
                    info.inventory,
                    info.requested,
                    info.remaining,
                    buildTabsListElement(info.overlapping),
                    statusCell
                ];
            });

            const table = TableManager.buildTable(rows, headers);
            table.classList.add('quantity-check-table');
            
            // Create a div to hold the table with a logical heading
            const inventoryReportContainer = document.createElement('div');
            const heading = document.createElement('h2');
            heading.textContent = `Inventory report:`;
            inventoryReportContainer.classList.add('inventory-report-container');
            inventoryReportContainer.appendChild(heading);
            inventoryReportContainer.appendChild(table);
            container.appendChild(inventoryReportContainer);

            // For each inventory item with an error, find the pack list table and scan for
            // the corresponding item to highlight it
            // Find error items from rows (statusCell.textContent !== 'OK')
            console.log('Highlighting error items in pack list table...');
            rows.forEach(row => {
                const itemId = row[0];
                const remaining = row[3];
                const statusCell = row[row.length - 1];
                if (remaining < 0) {
                    // Insufficient inventory: red
                    const packListItems = container.querySelectorAll('.drag-id-pack-list-items td');
                    packListItems.forEach(packListItem => {
                        const itemRegex = /(?:\(([0-9]+)\))?\s*([A-Z]+-[0-9]+[a-zA-Z]?)/;
                        const match = packListItem.textContent.match(itemRegex);
                        if (match && match[2] === itemId) {
                            TableManager.tableCellCard(packListItem, `<strong>Warning: </strong>insufficient inventory (${remaining})`, 'red', '.inventory-report-container');
                        }
                    });
                } else if (remaining === 0) {
                    // No inventory margin: yellow
                    const packListItems = container.querySelectorAll('.drag-id-pack-list-items td');
                    packListItems.forEach(packListItem => {
                        const itemRegex = /(?:\(([0-9]+)\))?\s*([A-Z]+-[0-9]+[a-zA-Z]?)/;
                        const match = packListItem.textContent.match(itemRegex);
                        if (match && match[2] === itemId) {
                            TableManager.tableCellCard(packListItem, '<strong>Warning: </strong>no inventory margin', 'yellow', '.inventory-report-container');
                        }
                    });
                }
            });

        } catch (err) {
            console.error('Error building quantity check table:', err && err.stack ? err.stack : err);
            ModalManager.alert('Failed to check item quantities.');
        }
    }

    // Extracted function to build the tabs-list DOM element from a list of sheetTabs
    function buildTabsListElement(sheetTabs) {
        if (!sheetTabs || sheetTabs.length === 0) {
            const noTabsMessage = document.createElement('p');
            noTabsMessage.textContent = '-';
            return noTabsMessage;
        }
        
        const tabsList = document.createElement('div');
        tabsList.className = 'tabs-list';
        for (const tabName of sheetTabs) {
            if (tabName === 'TEMPLATE') continue;
            const tabButton = document.createElement('button');
            tabButton.classList.add('tab-button');
            tabButton.textContent = tabName;
            tabsList.appendChild(tabButton);
            tabButton.addEventListener('click', async () => {
                const loadingModal = ModalManager.showLoadingIndicator('Fetching and analyzing pack list...');
                try {
                    const content = await GoogleSheetsService.getPackListContent(tabName);
                    const tabContainer = document.createElement('div');
                    // Pass tabName to buildPackListTable so save buttons are added
                    const packListTable = buildPackListTable(content, tabName);
                    tabContainer.appendChild(packListTable);

                    // Asynchronously check item quantities
                    checkPackListQuantities(tabName, tabContainer);

                    TabManager.addNewTab('tabSystem', tabName, tabContainer, true, true);
                    loadingModal.hide();
                } catch (error) {
                    loadingModal.hide();
                    console.error('Error loading sheet content:', error);
                    ModalManager.alert('Failed to load spreadsheet content');
                }
                // Remove modal if present
                const modal = document.querySelector('.modal');
                if (modal) modal.remove();
            });
        }
        return tabsList;
    }

    // Standalone function for TabManager tab handler
    async function addNewPackListTab() {
        await GoogleSheetsAuth.checkAuth();

        const modal = ModalManager.createModal(`
            <p class="loading-message">Loading...</p>
        `);

        try {
            const sheetTabs = await GoogleSheetsService.getSheetTabs(SPREADSHEET_IDS.PACK_LISTS);
            const tabsListElement = buildTabsListElement(sheetTabs);
            const modalBody = modal.querySelector('.modal-body');
            modalBody.innerHTML = '';
            modalBody.appendChild(tabsListElement);
        } catch (error) {
            console.error('Error loading sheet tabs:', error);
            modal.querySelector('.modal-body').innerHTML = '<p class="error">Failed to load spreadsheet tabs</p>';
        }
    }

    /**
     * Save the entire pack list table (all crates and their items) to Google Sheets.
     * Only writes data rows (no header row).
     * @param {HTMLTableElement} mainTable - The main pack list table element.
     * @param {string} sheetId - The Google Sheets ID.
     * @param {string} tabName - The sheet/tab name.
     * @param {function} setSheetData - Function to call for saving (should match GoogleSheetsService.setSheetData).
     * @returns {Promise<void>}
     */
    async function savePackListTable(mainTable, sheetId, tabName, setSheetData) {
        // Show loading modal
        const loadingModal = ModalManager.showLoadingIndicator('Saving pack list...');
        try {
            // Get main headers (skip drag handle th)
            const thead = mainTable.querySelector('thead');
            let mainHeaders = [];
            if (thead) {
                const headerRow = thead.querySelector('tr');
                if (headerRow) {
                    mainHeaders = Array.from(headerRow.querySelectorAll('th'))
                        .slice(1) // skip drag handle
                        .map(th => th.textContent.trim());
                }
            }

            // Find the index of the "Items" column
            const itemsColIdx = mainHeaders.findIndex(h => h === 'Items');
            // The columns before "Items" are crate info columns
            const crateInfoCols = mainHeaders.slice(0, itemsColIdx);

            // Compose the spreadsheet rows (no header row)
            const result = [];
            // We'll get item headers from the first crate with items
            let itemHeaders = [];
            const tbody = mainTable.querySelector('tbody');
            const crateRows = Array.from(tbody.querySelectorAll('tr'));
            for (const crateRow of crateRows) {
                const crateCells = Array.from(crateRow.querySelectorAll('td'));
                if (crateCells.length === 0) continue;
                // Crate info: skip drag handle, up to but not including "Items"
                const crateInfo = crateCells.slice(1, 1 + crateInfoCols.length).map(td => td.textContent.trim());
                const itemsCell = crateCells[crateCells.length - 1];
                // Find the nested items table
                const itemsTable = itemsCell.querySelector('table');
                if (itemsTable && itemHeaders.length === 0) {
                    // Get item headers (skip drag handle)
                    const itemsThead = itemsTable.querySelector('thead');
                    if (itemsThead) {
                        const itemsHeaderRow = itemsThead.querySelector('tr');
                        if (itemsHeaderRow) {
                            itemHeaders = Array.from(itemsHeaderRow.querySelectorAll('th'))
                                .slice(1)
                                .map(th => th.textContent.trim());
                        }
                    }
                }
            }

            // Now process each crate row
            for (const crateRow of crateRows) {
                const crateCells = Array.from(crateRow.querySelectorAll('td'));
                if (crateCells.length === 0) continue;
                const crateInfo = crateCells.slice(1, 1 + crateInfoCols.length).map(td => td.textContent.trim());
                const itemsCell = crateCells[crateCells.length - 1];
                const itemsTable = itemsCell.querySelector('table');
                let hasItems = false;
                if (itemsTable) {
                    const itemsTbody = itemsTable.querySelector('tbody');
                    if (itemsTbody) {
                        const itemRows = Array.from(itemsTbody.querySelectorAll('tr'));
                        for (const itemTr of itemRows) {
                            // Get item columns (skip drag handle)
                            const itemTds = Array.from(itemTr.querySelectorAll('td')).slice(1);
                            const itemData = itemTds.map(td => {
                                const editable = td.querySelector('.table-edit-textarea');
                                return editable ? editable.textContent.trim() : td.textContent.trim();
                            });
                            // Only push if at least one item cell is non-empty
                            if (itemData.some(cell => cell.length > 0)) {
                                // Crate info columns are blank except for the first item row (per crate)
                                result.push([
                                    ...crateInfo,
                                    ...itemData
                                ]);
                                // For subsequent item rows, crate info columns are blank
                                crateInfoCols.forEach((_, idx) => crateInfo[idx] = '');
                                hasItems = true;
                            }
                        }
                    }
                }
                if (!hasItems) {
                    // No items, just push crate info row with empty item columns
                    result.push([
                        ...crateInfo,
                        ...itemHeaders.map(() => '')
                    ]);
                }
            }

            // Save to Google Sheets (no header row)
            // Ensure updates is an array before using .map()
            // (no .map() is used in this function, but if you see updates.map() elsewhere, check the type)
            await setSheetData(sheetId, tabName, {
                type: 'full-table',
                values: Array.isArray(result) ? result : []
            });
        } finally {
            loadingModal.hide();
        }
    }

    // Initialize the TabManager with tab handler
    TabManager.buildTabSystem('tabSystem', addNewPackListTab);


</script>